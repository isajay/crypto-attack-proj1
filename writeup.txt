1. The length extension attack carried out in Part 1.2 relies on the fact that you have direct access to the hash result of the key | message (plus padding), to which you can then set the internal state of the hash function and continue using this function to validly add whatever you want to the message. This is exactly what we did in Part 1.2 because the poorly-constructed token was just this direct hash. HMAC has a nested hashing scheme, wherein the hash result of the key | message (plus padding) is then hashed again (and padded), so the token generated using an HMAC construction is not the direct hash needed to set the internal state of the hash function for a length extension attack.
2. In Section 2.2, we used a program that, given a prefix, could generate two different documents with the same MD5 hash. Assuming that systems sign off on the integrity of programs by verifying their MD5 hash, it would be possible to use a program like the one we used in Section 2.2 to generate a malicious program that has the same MD5 hash as an approved, benign one; the package manager would erroneously sign off on this malicious program since the MD5 hash would reflect that of a benign program.
3. Attacks aiming to decrypt RSA ciphertexts without the private key are carried out by trying to reverse the equation used to generate the ciphertext, C = P^e (mod N), to reveal the message P. This requires trying to find the e-th root of some number, mod N. There’s nothing inherently wrong with using an exponent lower than e if the padding implementation is entirely correct, but because people inevitably make implementation errors, low public exponents are more susceptible to attacks like Bleichenbacher’s. With e = 3, Bleichenbacher was able to approximate P by just cube-rooting C and ignoring the mod N because with a public exponent as small as 3, many values of P^e weren’t large enough to wrap the modulus. By making e much larger (at least 2^16 + 1), it becomes extremely difficult to take this approach because the generated values make the modulus relevant and the eth root much harder to compute.
